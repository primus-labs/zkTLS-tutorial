## Overview

zkTLS verifies TLS data authenticity while preserving privacy, without modifying servers. It enables secure use of Web2 personal data for efficient cross-platform flow.

## Try with a Quick Demo
Here is a small demo that shows how to use Primus zkTLS to prove your Binance KYC status. 
- https://github.com/xiafubiao/proof-of-kyc

## Build with Primus zkTLS Network (AlphaNet)
Note Primus zkTLS uses two components, **data templates** and **zkTLS SDKs**, to help the developers create their business logic towards off-chain data. 

On the zkTLS attestor side, Primus zkTLS is now deployed within a decentralized attestor group, i.e., Primus AlphaNet, to support dapps execute data verification tasks. Refer to this [doc](https://docs.primuslabs.xyz/primus-network/build-with-primus/overview) for more details about the network. Developers can simply use the SDKs to create their own zkTLS application on Primus AlphaNet.

### 1. Data Templates
Off-chain data sources can be formalized and represented as pre-defined templates to simplify the development. [Primus Developer Hub](https://dev.primuslabs.xyz) is a developer tool that provides a plug-and-play way of connecting data sources and creating related templates in the market. Users can find useful data templates through the market of [Primus Developer Hub](https://dev.primuslabs.xyz), and they can further create their own data templates there. Once the template is selected, they can simply use the template ID in their application to interact with the network attestors.

### 2. Primus zkTLS SDKs
Primus SDKs are the core tools that can be used in one's dapp code. In most scenarios, end users operate the zkTLS dapp and create their data attestations and share them on-chain. While in some cases, the attestations are generated by the service provider or another party, rather than through the end users. For instance, a user can send his credentials (api keys/password/access tokens) to an agent program, where the agent program generates zkTLS attestations on behalf of the user. To fulfil the different use cases, Primus offers two types of integration modes with related SDKs.

üß© **For Dapp Integration (User need to install Primus Extension)**
Note that this integration will require end users to install the Primus Chrome Extension to activate the proof generation on their local devices.
- [Install Guide](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-developers/install)
- [Example](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-developers/example#complete-example)

‚öôÔ∏è **For Backend Integration**
Note this type of integration, developers should use Primus Network Core SDK in their dapps.
- [Installation](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-backend/install)
- [Example](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-backend/simpleexample#implementation)

### More About Primus zkTLS

Primus zkTLS supports two algorithm modes, each with different trade-offs between security and performance.

 **1. MPC Mode**

The attestor and client jointly execute secure multi-party computation to generate TLS session materials, preventing the client from modifying data before the attestor returns its key share.

Primus' MPC mode uses [QuickSilver](https://eprint.iacr.org/2021/076), an efficient interactive zero-knowledge proof system. QuickSilver significantly reduces computational and communication overhead. See our [whitepaper](https://eprint.iacr.org/2023/964) for details.

üí° **Use MPC mode** when integrity against client-side tampering is your highest priority.

**2. Proxy Mode**

The attestor intermediates between client and server, forwarding TLS traffic and recording ciphertexts. At the session end, the client proves that it knows the plaintext messages.

Proxy mode offers better performance by avoiding multi-party computation overhead. However, the attestor must verify it's communicating with the intended server.

Primus' Proxy mode uses the efficient [QuickSilver](https://eprint.iacr.org/2021/076) protocol and proves Key Derivation Functions (KDFs) during TLS establishment‚Äîtypically inefficient in zk-SNARK alternatives. This eliminates extra padding.

üí° **Use Proxy mode** when performance and throughput are key considerations.

You can pick your own algorithm type in your code by configuring the `attMode` parameter with "proxytls" or "mpctls" in the `attest` function. Check [here](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-developers/example#parameter-description-2) for more details.

### Error Codes 
Check [here](https://docs.primuslabs.xyz/primus-network/build-with-primus/for-developers/errorcode) for the defined errors about zkTLS in the Primus SDKs.

### **Advanced Material: Private Data Verification and Computation -- Build zkTLS with zkVM**

zkTLS provides off-chain data verifiability, but in most real scenarios, a user‚Äôs personal data must remain private while still being computable. This requires another privacy-preserving computation technique, namely a zkVM,  to work alongside zkTLS. Together, they enable **Data Verification & Computation (DVC)**, allowing applications to verify and compute on private data securely.

Primus zkTLS enables DVC by passing user data attestation and its hash value to the zkVM, where the zk proof is generated on the private data and its metadata restrictions. The zk proof can be verified on-chain for better scalability and privacy. You may check this [content](https://github.com/primus-labs/DVC-Demo/blob/main/DEVELOPER_GUIDE.md) for more details.

You can also check this demo [repo](https://github.com/primus-labs/DVC-Demo) to see how primus zkTLS can be combined with zkVM to provide a private data verification and computation capability to applications.

